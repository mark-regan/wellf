package services

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/mark-regan/wellf/internal/models"
	"github.com/mark-regan/wellf/internal/repository"
)

// ReminderGenerator generates automatic reminders from various domains
type ReminderGenerator struct {
	reminderRepo  *repository.ReminderRepository
	plantRepo     *repository.PlantRepository
	householdRepo *repository.HouseholdRepository
}

// NewReminderGenerator creates a new reminder generator service
func NewReminderGenerator(
	reminderRepo *repository.ReminderRepository,
	plantRepo *repository.PlantRepository,
) *ReminderGenerator {
	return &ReminderGenerator{
		reminderRepo: reminderRepo,
		plantRepo:    plantRepo,
	}
}

// SetHouseholdRepo sets the household repository for generating household reminders
func (g *ReminderGenerator) SetHouseholdRepo(repo *repository.HouseholdRepository) {
	g.householdRepo = repo
}

// GenerateAll generates reminders for all domains
func (g *ReminderGenerator) GenerateAll(ctx context.Context, userID uuid.UUID) error {
	var lastErr error

	if err := g.generatePlantReminders(ctx, userID); err != nil {
		lastErr = err
	}

	if err := g.generateHouseholdReminders(ctx, userID); err != nil {
		lastErr = err
	}

	return lastErr
}

// GenerateForDomain generates reminders for a specific domain
func (g *ReminderGenerator) GenerateForDomain(ctx context.Context, userID uuid.UUID, domain string) error {
	switch domain {
	case "plants":
		return g.generatePlantReminders(ctx, userID)
	case "household":
		return g.generateHouseholdReminders(ctx, userID)
	default:
		return nil
	}
}

// generatePlantReminders creates reminders for plants needing water and fertilizing
func (g *ReminderGenerator) generatePlantReminders(ctx context.Context, userID uuid.UUID) error {
	if g.plantRepo == nil {
		return nil
	}

	// Generate watering reminders
	if err := g.generateWateringReminders(ctx, userID); err != nil {
		// Log but continue
	}

	// Generate fertilizing reminders
	if err := g.generateFertilizingReminders(ctx, userID); err != nil {
		// Log but continue
	}

	return nil
}

// generateWateringReminders creates reminders for plants needing water
func (g *ReminderGenerator) generateWateringReminders(ctx context.Context, userID uuid.UUID) error {
	// Get plants that need watering in the next 7 days
	plants, err := g.plantRepo.GetNeedingWater(ctx, userID, 7)
	if err != nil {
		return fmt.Errorf("failed to get plants needing water: %w", err)
	}

	for _, plant := range plants {
		if plant.NextWaterDate == nil {
			continue
		}

		entityID := plant.ID
		entityType := "plant"
		entityName := plant.Name
		autoKey := fmt.Sprintf("plant-water-%s", plant.ID.String())

		reminder := &models.Reminder{
			UserID:             userID,
			Domain:             "plants",
			EntityType:         &entityType,
			EntityID:           &entityID,
			EntityName:         &entityName,
			Title:              fmt.Sprintf("Water %s", plant.Name),
			ReminderDate:       *plant.NextWaterDate,
			IsAllDay:           true,
			IsRecurring:        true,
			RecurrenceType:     strPtr(models.RecurrenceCustom),
			RecurrenceInterval: plant.WateringFrequencyDays,
			Priority:           models.ReminderPriorityNormal,
			IsAutoGenerated:    true,
			AutoGenerateKey:    &autoKey,
		}

		// Add description with location if available
		if plant.Room != "" {
			desc := fmt.Sprintf("Water your %s in the %s", plant.Name, plant.Room)
			reminder.Description = &desc
		}

		// Use upsert to avoid duplicates
		if err := g.reminderRepo.UpsertByAutoKey(ctx, reminder); err != nil {
			// Log but continue with other plants
			continue
		}
	}

	return nil
}

// generateFertilizingReminders creates reminders for plants needing fertilizer
func (g *ReminderGenerator) generateFertilizingReminders(ctx context.Context, userID uuid.UUID) error {
	// Get plants that need fertilizing in the next 14 days
	plants, err := g.plantRepo.GetNeedingFertilizer(ctx, userID, 14)
	if err != nil {
		return fmt.Errorf("failed to get plants needing fertilizer: %w", err)
	}

	for _, plant := range plants {
		if plant.NextFertilizeDate == nil || plant.FertilizingFrequencyDays == nil {
			continue
		}

		entityID := plant.ID
		entityType := "plant"
		entityName := plant.Name
		autoKey := fmt.Sprintf("plant-fertilize-%s", plant.ID.String())

		reminder := &models.Reminder{
			UserID:             userID,
			Domain:             "plants",
			EntityType:         &entityType,
			EntityID:           &entityID,
			EntityName:         &entityName,
			Title:              fmt.Sprintf("Fertilize %s", plant.Name),
			ReminderDate:       *plant.NextFertilizeDate,
			IsAllDay:           true,
			IsRecurring:        true,
			RecurrenceType:     strPtr(models.RecurrenceCustom),
			RecurrenceInterval: *plant.FertilizingFrequencyDays,
			Priority:           models.ReminderPriorityLow,
			IsAutoGenerated:    true,
			AutoGenerateKey:    &autoKey,
		}

		// Add description with location if available
		desc := fmt.Sprintf("Fertilize your %s", plant.Name)
		if plant.Room != "" {
			desc = fmt.Sprintf("Fertilize your %s in the %s", plant.Name, plant.Room)
		}
		reminder.Description = &desc

		// Use upsert to avoid duplicates
		if err := g.reminderRepo.UpsertByAutoKey(ctx, reminder); err != nil {
			// Log but continue with other plants
			continue
		}
	}

	return nil
}

// generateHouseholdReminders creates reminders for household items
func (g *ReminderGenerator) generateHouseholdReminders(ctx context.Context, userID uuid.UUID) error {
	if g.householdRepo == nil {
		return nil
	}

	// Generate bill reminders
	if err := g.generateBillReminders(ctx, userID); err != nil {
		// Log but continue
	}

	// Generate insurance renewal reminders
	if err := g.generateInsuranceReminders(ctx, userID); err != nil {
		// Log but continue
	}

	// Generate maintenance task reminders
	if err := g.generateMaintenanceReminders(ctx, userID); err != nil {
		// Log but continue
	}

	return nil
}

// generateBillReminders creates reminders for upcoming bills
func (g *ReminderGenerator) generateBillReminders(ctx context.Context, userID uuid.UUID) error {
	bills, err := g.householdRepo.ListBills(ctx, userID, true) // Active only
	if err != nil {
		return fmt.Errorf("failed to get bills: %w", err)
	}

	for _, bill := range bills {
		if bill.NextDueDate == nil {
			continue
		}

		// Only create reminders for bills due in the next 14 days
		if bill.DaysUntilDue != nil && (*bill.DaysUntilDue > 14 || *bill.DaysUntilDue < -7) {
			continue
		}

		entityID := bill.ID
		entityType := "bill"
		entityName := bill.Name
		autoKey := fmt.Sprintf("bill-due-%s", bill.ID.String())

		// Determine priority based on days until due
		priority := models.ReminderPriorityNormal
		if bill.IsOverdue {
			priority = models.ReminderPriorityUrgent
		} else if bill.DaysUntilDue != nil && *bill.DaysUntilDue <= 3 {
			priority = models.ReminderPriorityHigh
		}

		reminder := &models.Reminder{
			UserID:             userID,
			Domain:             "household",
			EntityType:         &entityType,
			EntityID:           &entityID,
			EntityName:         &entityName,
			Title:              fmt.Sprintf("Pay %s", bill.Name),
			ReminderDate:       *bill.NextDueDate,
			IsAllDay:           true,
			IsRecurring:        bill.Frequency != "one_time",
			Priority:           priority,
			NotifyDaysBefore:   bill.ReminderDays,
			IsAutoGenerated:    true,
			AutoGenerateKey:    &autoKey,
		}

		// Set recurrence based on bill frequency
		if bill.Frequency != "one_time" {
			reminder.RecurrenceType = strPtr(frequencyToRecurrence(bill.Frequency))
			reminder.RecurrenceInterval = 1
		}

		// Add description with amount
		desc := fmt.Sprintf("Pay %s - %s %.2f", bill.Name, bill.Currency, bill.Amount)
		if bill.Provider != "" {
			desc += fmt.Sprintf(" to %s", bill.Provider)
		}
		if bill.AutoPay {
			desc += " (Auto-pay enabled)"
		}
		reminder.Description = &desc

		if err := g.reminderRepo.UpsertByAutoKey(ctx, reminder); err != nil {
			continue
		}
	}

	return nil
}

// generateInsuranceReminders creates reminders for insurance renewals
func (g *ReminderGenerator) generateInsuranceReminders(ctx context.Context, userID uuid.UUID) error {
	policies, err := g.householdRepo.ListInsurancePolicies(ctx, userID, true) // Active only
	if err != nil {
		return fmt.Errorf("failed to get insurance policies: %w", err)
	}

	for _, policy := range policies {
		if policy.RenewalDate == nil {
			continue
		}

		// Only create reminders for policies renewing in the next 30 days
		if policy.DaysUntilRenewal != nil && (*policy.DaysUntilRenewal > 30 || *policy.DaysUntilRenewal < -7) {
			continue
		}

		entityID := policy.ID
		entityType := "insurance"
		entityName := policy.Name
		autoKey := fmt.Sprintf("insurance-renewal-%s", policy.ID.String())

		// Determine priority based on days until renewal
		priority := models.ReminderPriorityNormal
		if policy.DaysUntilRenewal != nil && *policy.DaysUntilRenewal <= 7 {
			priority = models.ReminderPriorityHigh
		}

		reminder := &models.Reminder{
			UserID:           userID,
			Domain:           "household",
			EntityType:       &entityType,
			EntityID:         &entityID,
			EntityName:       &entityName,
			Title:            fmt.Sprintf("%s Insurance Renewal", policy.Name),
			ReminderDate:     *policy.RenewalDate,
			IsAllDay:         true,
			IsRecurring:      true,
			RecurrenceType:   strPtr(models.RecurrenceYearly),
			RecurrenceInterval: 1,
			Priority:         priority,
			NotifyDaysBefore: 14, // Notify 2 weeks before
			IsAutoGenerated:  true,
			AutoGenerateKey:  &autoKey,
		}

		// Add description
		desc := fmt.Sprintf("Review and renew your %s policy with %s", policy.PolicyType, policy.Provider)
		if policy.AnnualPremium > 0 {
			desc += fmt.Sprintf(" - Annual premium: %s %.2f", policy.Currency, policy.AnnualPremium)
		}
		reminder.Description = &desc

		if err := g.reminderRepo.UpsertByAutoKey(ctx, reminder); err != nil {
			continue
		}
	}

	return nil
}

// generateMaintenanceReminders creates reminders for maintenance tasks
func (g *ReminderGenerator) generateMaintenanceReminders(ctx context.Context, userID uuid.UUID) error {
	tasks, err := g.householdRepo.ListMaintenanceTasks(ctx, userID, true) // Active only
	if err != nil {
		return fmt.Errorf("failed to get maintenance tasks: %w", err)
	}

	for _, task := range tasks {
		if task.NextDueDate == nil {
			continue
		}

		// Only create reminders for tasks due in the next 30 days
		if task.DaysUntilDue != nil && (*task.DaysUntilDue > 30 || *task.DaysUntilDue < -14) {
			continue
		}

		entityID := task.ID
		entityType := "maintenance"
		entityName := task.Name
		autoKey := fmt.Sprintf("maintenance-due-%s", task.ID.String())

		// Map task priority to reminder priority
		priority := models.ReminderPriorityNormal
		switch task.Priority {
		case "urgent":
			priority = models.ReminderPriorityUrgent
		case "high":
			priority = models.ReminderPriorityHigh
		case "low":
			priority = models.ReminderPriorityLow
		}

		// Increase priority if overdue
		if task.IsOverdue {
			priority = models.ReminderPriorityUrgent
		}

		reminder := &models.Reminder{
			UserID:           userID,
			Domain:           "household",
			EntityType:       &entityType,
			EntityID:         &entityID,
			EntityName:       &entityName,
			Title:            task.Name,
			ReminderDate:     *task.NextDueDate,
			IsAllDay:         true,
			IsRecurring:      task.Frequency != "" && task.Frequency != "as_needed",
			Priority:         priority,
			NotifyDaysBefore: task.ReminderDays,
			IsAutoGenerated:  true,
			AutoGenerateKey:  &autoKey,
		}

		// Set recurrence based on task frequency
		if task.FrequencyMonths != nil && *task.FrequencyMonths > 0 {
			reminder.RecurrenceType = strPtr(models.RecurrenceCustom)
			reminder.RecurrenceInterval = *task.FrequencyMonths * 30 // Approximate days
		} else if task.Frequency != "" {
			reminder.RecurrenceType = strPtr(frequencyToRecurrence(task.Frequency))
			reminder.RecurrenceInterval = 1
		}

		// Add description
		desc := fmt.Sprintf("Home maintenance: %s (%s)", task.Name, task.Category)
		if task.Description != "" {
			desc = task.Description
		}
		if task.EstimatedCost != nil {
			desc += fmt.Sprintf(" - Estimated cost: Â£%.2f", *task.EstimatedCost)
		}
		if task.TypicalProvider != "" {
			desc += fmt.Sprintf(" - Provider: %s", task.TypicalProvider)
		}
		reminder.Description = &desc

		if err := g.reminderRepo.UpsertByAutoKey(ctx, reminder); err != nil {
			continue
		}
	}

	return nil
}

// frequencyToRecurrence converts bill/task frequency to recurrence type
func frequencyToRecurrence(freq string) string {
	switch freq {
	case "weekly":
		return models.RecurrenceWeekly
	case "fortnightly":
		return models.RecurrenceCustom // 14 days
	case "monthly":
		return models.RecurrenceMonthly
	case "quarterly":
		return models.RecurrenceCustom // 3 months
	case "biannually":
		return models.RecurrenceCustom // 6 months
	case "annually":
		return models.RecurrenceYearly
	default:
		return models.RecurrenceMonthly
	}
}

// Helper function for string pointers
func strPtr(s string) *string {
	return &s
}
